// --- GAME 3: SPARTAN ARCHERY TRIAL (UPDATED FOR IPAD) ---
const archeryData = [
    { quote: "The war is inevitable... let it come!", answer: "To persuade for war", options: ["To inform about history", "To entertain with stories"] },
    { quote: "He has plundered our seas, ravaged our Coasts...", answer: "To provoke emotion (Pathos)", options: ["To show off writing skill", "To appeal to logic"] },
    { quote: "Sir, we are not weak if we make a proper use of those means...", answer: "To build audience's confidence", options: ["To criticize the audience", "To ask for money"] },
    { quote: "To prove this, let Facts be submitted...", answer: "To appeal to logic (Logos)", options: ["To build suspense", "To appeal to emotion"] },
    { quote: "Who is Patrick Henry's intended audience?", answer: "Members of the Convention", options: ["The King of Great Britain", "The general public"] },
    { quote: "Who is the source of authority for the Declaration?", answer: "The People of the Colonies", options: ["The Representatives", "The Supreme Judge"] }
];
let archeryCtx, archeryState, archeryPlayer, archeryArrow, archeryTargets, archeryQuestions;
let isArcheryInitialized = false; // Prevent multiple listener attachments

function initArcheryGame() {
    const canvas = document.getElementById('archeryCanvas');
    archeryCtx = canvas.getContext('2d');
    
    // Make canvas responsive
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.width * (5/8); // Maintain 800x500 aspect ratio

    archeryQuestions = [...archeryData].sort(() => Math.random() - 0.5);
    archeryState = { gameOver: false, targetsHit: 0, mouse: {x: canvas.width, y: canvas.height/2} };
    archeryPlayer = { x: 50, y: canvas.height - 50, angle: 0 };
    archeryArrow = null;

    if (!isArcheryInitialized) {
        const handleAim = (e) => {
            if(sections[currentSectionIndex] !== 'game3-archery') return;
            const rect = canvas.getBoundingClientRect();
            // Use touch coordinates if they exist, otherwise use mouse coordinates
            const x = e.touches ? e.touches[0].clientX : e.clientX;
            const y = e.touches ? e.touches[0].clientY : e.clientY;
            archeryState.mouse.x = x - rect.left;
            archeryState.mouse.y = y - rect.top;
        };

        // FIXED: This function now accepts the event 'e' to update aim on tap
        const handleShoot = (e) => {
             if(sections[currentSectionIndex] !== 'game3-archery' || archeryArrow) return;
             
             // CRITICAL FIX: Update the aim position based on the tap/click location first!
             handleAim(e);
             
             const angle = Math.atan2(archeryState.mouse.y - archeryPlayer.y, archeryState.mouse.x - archeryPlayer.x);
             archeryArrow = { x: archeryPlayer.x, y: archeryPlayer.y, dx: Math.cos(angle) * 15, dy: Math.sin(angle) * 15, angle: angle };
        };

        // Add both mouse and touch listeners
        canvas.addEventListener('mousemove', handleAim);
        canvas.addEventListener('touchmove', e => { e.preventDefault(); handleAim(e); });
        
        // FIXED: The event 'e' is now passed to the handleShoot function
        canvas.addEventListener('click', handleShoot);
        canvas.addEventListener('touchstart', e => { e.preventDefault(); handleShoot(e); });

        isArcheryInitialized = true;
    }

    nextArcheryRound();
    archeryGameLoop();
}

// The rest of the Archery Game functions (nextArcheryRound, updateArchery, drawArchery, archeryGameLoop) remain the same as before.
// You do not need to copy them again if they are already in your file.
function nextArcheryRound() {
    archeryArrow = null;
    if (archeryQuestions.length === 0) {
        archeryState.gameOver = true;
        showGameMessage('Challenge Complete!', 'Your aim is true! You have mastered textual analysis.', 'Finish Review', advanceToNextGame);
        return;
    }
    const currentQuestion = archeryQuestions.pop();
    document.getElementById('archery-quote').textContent = `"${currentQuestion.quote}"`;
    document.getElementById('archery-hit').textContent = `${archeryState.targetsHit} / ${archeryData.length}`;
    
    archeryTargets = [];
    const allOptions = [currentQuestion.answer, ...currentQuestion.options].sort(() => Math.random() - 0.5);
    allOptions.forEach((opt, i) => {
        const targetWidth = archeryCtx.canvas.width * 0.3;
        const targetX = archeryCtx.canvas.width * 0.6 + Math.random() * (archeryCtx.canvas.width * 0.1);
        archeryTargets.push({ x: targetX, y: 50 + i * 110, width: targetWidth, height: 50, text: opt, isCorrect: opt === currentQuestion.answer, dy: (Math.random() - 0.5) * 2 });
    });
}

function updateArchery() {
    if (archeryState.gameOver) return;

    archeryPlayer.angle = Math.atan2(archeryState.mouse.y - archeryPlayer.y, archeryState.mouse.x - archeryPlayer.x);
    archeryTargets.forEach(t => {
        t.y += t.dy;
        if (t.y < 0 || t.y + t.height > archeryCtx.canvas.height) t.dy *= -1;
    });

    if (archeryArrow) {
        archeryArrow.x += archeryArrow.dx;
        archeryArrow.y += archeryArrow.dy;
        if (archeryArrow.x > archeryCtx.canvas.width || archeryArrow.y < 0 || archeryArrow.y > archeryCtx.canvas.height) {
            restartCurrentGame('You missed the targets.');
            return;
        }
        for(const target of archeryTargets) {
            if (archeryArrow.x > target.x && archeryArrow.x < target.x + target.width && archeryArrow.y > target.y && archeryArrow.y < target.y + target.height) {
                if (target.isCorrect) {
                    archeryState.targetsHit++;
                    nextArcheryRound();
                } else {
                    restartCurrentGame('You hit the wrong target.');
                }
                return;
            }
        }
    }
}

function drawArchery() {
    if (!archeryCtx) return;
    archeryCtx.clearRect(0, 0, archeryCtx.canvas.width, archeryCtx.canvas.height);
    archeryTargets.forEach(t => {
        archeryCtx.fillStyle = '#006b3f';
        archeryCtx.fillRect(t.x, t.y, t.width, t.height);
        archeryCtx.fillStyle = '#fff';
        archeryCtx.font = '14px Montserrat';
        archeryCtx.textAlign = 'center';
        archeryCtx.textBaseline = 'middle';
        archeryCtx.fillText(t.text, t.x + t.width/2, t.y + t.height/2);
    });

    if (archeryArrow) {
        archeryCtx.save();
        archeryCtx.translate(archeryArrow.x, archeryArrow.y);
        archeryCtx.rotate(archeryArrow.angle);
        archeryCtx.fillStyle = '#fff';
        archeryCtx.fillRect(0, -2, 40, 4);
        archeryCtx.restore();
    }
    
    archeryCtx.save();
    archeryCtx.translate(archeryPlayer.x, archeryPlayer.y);
    archeryCtx.rotate(archeryPlayer.angle);
    archeryCtx.fillStyle = '#ccc';
    archeryCtx.fillRect(0, -5, 50, 10);
    archeryCtx.fillRect(20, -15, 10, 30);
    archeryCtx.restore();
}

function archeryGameLoop() {
    if (archeryState.gameOver) {
        activeGameLoop = null;
        return;
    }
    
    updateArchery();
    drawArchery();

    activeGameLoop = requestAnimationFrame(archeryGameLoop);
}
